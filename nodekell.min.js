!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t=t||self).F={})}(this,function(t){"use strict";const n=32;class e{constructor(t){const e=new ArrayBuffer(t.BYTES_PER_ELEMENT*n);this._data=new t(e),this._ctor=t,this._length=0}_grow(t){const n=this._ctor.BYTES_PER_ELEMENT,e=new ArrayBuffer(t*n),a=new this._ctor(e),r=this._data;a.set(r),this._data=a}add(t){const n=this._length;n===this._data.length&&this._grow(2*n),this._data[n]=t,this._length+=1}get(t){return this._data[t]}set(t,n){this._data[t]=n}get length(){return this._length}clear(){this._length=0}*[Symbol.iterator](){for(let t=0;t<this._length;++t)yield this._data[t]}toArray(){return this._data.slice(0,this._length)}}class a{constructor(){this.head=this.tail=null}add(t){const n={value:t,next:null};this.head?this.tail.next=n:this.head=n,this.tail=n}_unsafePop(){const t=this.head;return t!==this.tail?this.head=t.next:this.head=this.tail=null,t.next=null,t.value}remove(){if(null===this.head)throw new Error("no such element");return this._unsafePop()}poll(){return null===this.head?null:this._unsafePop()}element(){const t=this.head;if(null===t)throw new Error("no such element");return t.value}peek(){const t=this.head;return null===t?null:t.value}isEmpty(){return null===this.head}clear(){let t=this.head;for(;t;){const n=t.next;t.value=t.next=null,t=n}this.head=this.tail=null}*[Symbol.iterator](){let t=this.head;for(;t;)yield t.value,t=t.next}*removeIterator(){let t=this.head;for(;t;){const n=t;yield n.value,t=n.next,n.value=null,n.next=null}}}const r=Object.freeze({}),o=r,i=t=>(...n)=>t.length<=n.length?t(...n):(...e)=>i(t)(...n,...e),s=i((t,n)=>t+n),c=(t,n)=>t>n?1:t<n?-1:0,l=t=>ArrayBuffer.isView(t)&&!(t instanceof DataView),f=t=>!!Number.isSafeInteger(t.length)&&(t=>0===t.length?1===Object.keys(t).length:Object.prototype.hasOwnProperty.call(t,t.length-1))(t),u=t=>t.constructor===String,y=t=>t&&(u(t)||(t=>Array.isArray(t)||l(t)||f(t))(t)),w=t=>t[Symbol.iterator]||t[Symbol.asyncIterator],d=t=>t&&t.constructor===Function,h=t=>{if(1&t.length)throw new Error("requires an even arguments")},p=i(async(t,n)=>{const e=new Map;for await(const a of n){const n=await t(a);y(n)?e.set(n[0],n[1]):e.set(n,n)}return e}),m=i(async function*(t,n){if((t=await t)<=0)throw new Error("arg supply > 0 required");let e=[];for await(const a of n){e.push(a)>=t&&(yield e,e=[])}0!==e.length&&(yield e)}),g=async t=>{const n=[];for await(const e of t)n.push(e);return n},b=t=>async n=>{const a=new e(t);for await(const t of n)a.add(t);return a.toArray()},v=b(Int8Array),x=b(Int16Array),_=b(Int32Array),E=b(Uint8Array),A=b(Uint16Array),O=b(Uint32Array),k=b(Uint8ClampedArray),j=b(Float32Array),B=b(Float64Array),I=t=>Array.isArray(t)?Promise.all(t):l(t)?t:u(t)?Array.from(t):f(t)?Promise.all(Array.from(t)):g(t),N=i(async function*(t,n){yield*t,yield*n}),S=N,P=(t,n)=>t<n?1:t>n?-1:0,M=async function*(...t){for await(const n of t){if(n){if(u(n)){yield*n;continue}if(w(n)){for await(const t of n)yield*M(t);continue}}yield n}},U=i(async function*(t,n){const e=new Set;for await(const a of n){const n=await t(a);e.has(n)||(e.add(n),yield a)}}),z=t=>t,F=t=>{const n=t[Symbol.asyncIterator];return n?n.call(t):async function*(t){for await(const n of t)yield n}(t)},T=t=>Array.isArray(t)||l(t)||u(t)?(async t=>{if(0!==t.length)return[await t[0],t.slice(1)]})(t):(async t=>{const n=F(t),e=await n.next();if(!e.done)return[e.value,n]})(t),q=async t=>{const n=await T(t);return n||(()=>{throw new Error("empty iter")})(),n};let C;const J=(t,n)=>{const e=t.length;if(e!==n.length)return!1;for(let a=e-1;a>=0;--a)if(!C(t[a],n[a]))return!1;return!0},L=t=>Object.prototype.toString(t),D=C=i((t,n)=>{if(t===n)return!0;if(t===r||n===r)return!0;if(t&&n){if(t.constructor!==n.constructor)return!1;if(t instanceof String||u(t)||t instanceof Number||t.constructor===Number||t instanceof Boolean||t.constructor===Boolean||t instanceof Date)return t.valueOf()===n.valueOf();if(t instanceof Array)return J(t,n);if(l(t))return((t,n)=>{const e=t.length;if(e!==n.length)return!1;for(let a=e-1;a>=0;--a)if(t[a]!==n[a])return!1;return!0})(t,n);if(f(t))return J(t,n);if(t instanceof Map)return((t,n)=>{if(t.size!==n.size)return!1;for(const e of t){if(!n.has(e[0]))return!1;if(!C(n.get(e[0]),e[1]))return!1}return!0})(t,n);if(t instanceof Set)return((t,n)=>{if(t.size!==n.size)return!1;for(const e of t)if(!n.has(e))return!1;return!0})(t,n);if(t instanceof RegExp)return((t,n)=>t.sticky===n.sticky&&(t.unicode===n.unicode&&(t.ignoreCase===n.ignoreCase&&(t.global===n.global&&(t.multiline===n.multiline&&t.source===n.source)))))(t,n);if(t instanceof Promise)return!1;if(L(t)!==L(n))return!1;if(t instanceof Object)return((t,n)=>{const e=Object.entries(t);if(e.length!==Object.keys(n).length)return!1;for(const[t,a]of e){if(!n.hasOwnProperty(t))return!1;if(!C(a,n[t]))return!1}return!0})(t,n)}else if(Number.isNaN(t)&&Number.isNaN(n))return!0;return!1}),W=i(async function*(t,n){let[e,a]=await q(n);yield e,e=await t(e);for await(const n of a){const a=await t(n);D(e,a)||(e=a,yield n)}}),R=W(z),V=i(async function*(t,n){const e=F(n);for(let n=0;n<t;n++){if((await e.next()).done)break}yield*e}),Y=async(t,n)=>{const e=await n.next();return!e.done&&(t.add(e.value),!0)},G=i(async function*(t,n){const e=F(n),r=new a;for(let n=0;n<t;n++)if(!await Y(r,e))return;for(;await Y(r,e);)yield r.poll()}),Q=i(async function*(t,n){const e=F(n);for(;;){const n=await e.next();if(n.done)return;if(!await t(n.value)){yield n.value;break}}yield*e}),H=i(async function*(t,n){for await(const t of n)return yield t,void(yield*n);(t=await t)instanceof Function?yield*await t():yield*t}),K=i(async function*(t,n){try{yield*n}catch(n){(t=await t)instanceof Function&&(t=await t(n)),t&&w(t)&&(yield*t)}}),X=i(async(t,n)=>{for await(const e of n)if(!await t(e))return!1;return!0}),Z=i(async function*(t,n){for await(const e of n)await t(e)&&(yield e)}),$=i(async function*(t,n){let e=0;for await(const a of n)await t(e++,a)&&(yield a)}),tt=i(async function*(t,n){for await(const e of n)await t(e)||(yield e)}),nt=i(async(t,n)=>{for await(const e of n)if(await t(e))return e}),et=i(async(t,n)=>{for(let e=(n=await I(n)).length-1;e>=0;--e)if(await t(n[e]))return n[e]}),at=i(async(t,n)=>{for await(const t of n)return t;return(t=await t)instanceof Function?await t():t}),rt=i(async function*(t,n){for await(const e of n)e&&w(e)?yield*await t(e):yield e}),ot=rt,it=()=>{},st=i(async(t,n,e)=>{n=await n;for await(const a of e)n=await t(n,a);return n}),ct=i(async(t,n)=>{const[e,a]=await q(n);return st(t,e,a)}),lt=ct,ft=async function*(t){const n=await I(t);for(let t=n.length-1;t>=0;t-=1)yield n[t]},ut=async(t,n,e)=>{n=await n;for await(const a of e)n=await t(a,n);return n},yt=i((t,n,e)=>ut(t,n,ft(e))),wt=i(async(t,n)=>{const e=ft(n),[a,r]=await q(e);return ut(t,a,r)}),dt=i(async(t,n)=>{const e=[];for await(const a of n)e.push(t(a));return Promise.all(e)}),ht=i(async(t,n)=>{const e=[];let a=0;for await(const r of n)e.push(t(a++,r));return Promise.all(e)}),pt=i(async(t,n)=>{const e=new Map;for await(const a of n){const n=await t(a),r=(e.get(n)||0)+1;e.set(n,r)}return e}),mt=pt(z),gt=i((t,n)=>{if(null!=n)return n[t]}),bt=i((t,n)=>{if(n&&d(n.get)){const e=n.get(t);if(void 0!==e)return e}return gt(t,n)}),vt=i((t,n,e)=>{const a=bt(t,e);return void 0===a?n:a}),xt=i(async(t,n)=>{const e=new Map;for await(const a of n){const n=await t(a),r=e.get(n);r?r.push(a):e.set(n,[a])}return e}),_t=i((t,n)=>!(!n.has||n.has.constructor!==Function||!n.has(t))||void 0!==n[t]),Et=t=>new Promise(n=>{setTimeout(n,t)}),At=t=>{if(t)return!1;switch(t){case null:case void 0:return!0;default:return Number.isNaN(t)}},Ot=i(async function*(t,n){for(n=await n,yield n;;)n=await t(n),yield n}),kt=i(async(t,n)=>{const e=(t=await I(t)).length,a=F(n),r=[];r.length=e;const o=await a.next();return o.done?r:(r.fill(o.value),st((n,e)=>ht((n,a)=>t[n](a,e),n),r,a))}),jt=i(async(t,n)=>{t=await I(t);const e=[];for(const a of t)e.push(bt(a,n));return e}),Bt=i(async function*(t,n){for await(const e of n)yield t(e)}),It=i(async function*(t,n){let e=0;for await(const a of n)yield t(e++,a)}),Nt=i(async(t,n)=>{let[e,a]=await q(n),r=await t(e);for await(const n of a){const a=await t(n);a>r&&(e=n,r=a)}return e}),St=Nt(z),Pt=i((t,n)=>{const e={};return async(...a)=>{let r;const o=await t(...a);return o in e?r=e[o]:(r=await n(...a),e[o]=r),r}}),Mt=Pt((...t)=>t),Ut=i((t,n)=>((t,n,e)=>{const a={};return async(...r)=>{const o=Date.now(),i=await n(...r),s=a[i];if(!s||o-s.time>t){const t=await e(...r);return a[r]={value:t,time:o},t}return s.value}})(t,(...t)=>t,n)),zt=i(async(t,n)=>{let[e,a]=await q(n),r=await t(e);for await(const n of a){const a=await t(n);a<r&&(e=n,r=a)}return e}),Ft=zt(z);let Tt=100;const qt=async(t,n)=>{const e=Tt-1,a=F(t);for(let t=e;t>0;--t){const t=await a.next();if(t.done)break;n(t.value)}return a},Ct=async function*(t){const n=new a,e=await((t,n)=>qt(n,n=>t.add(n())))(n,t);for await(const t of e)n.add(t()),yield n.poll();yield*n.removeIterator()},Jt=i(async function*(...t){1===t.length&&w(t[0])?yield*Ct(t[0]):yield*Ct(t)}),Lt=i(async function*(t,n){for await(const e of n)await t(e),yield e}),Dt=i(async function*(t,n){const e=new a,r=new a,o=await((t,n,e,a)=>qt(a,a=>{t.add(e(a)),n.add(a)}))(e,r,t,n);for await(const n of o){e.add(t(n)),r.add(n);const a=r.poll();await e.poll()&&(yield a)}for(;!r.isEmpty();){const t=r.poll();await e.poll()&&(yield t)}}),Wt=(t,n,e)=>qt(e,e=>t.add(n(e))),Rt=i(async function*(t,n){const e=new a,r=await Wt(e,t,n);for await(const n of r)e.add(t(n)),yield e.poll();yield*e.removeIterator()}),Vt=i(async function*(t,n){const e=new a,r=await Wt(e,t,n);for await(const n of r)e.add(t(n)),yield*await e.poll();for(;!e.isEmpty();)yield*await e.poll()}),Yt=Vt,Gt=i((t,n,e)=>{const a=gt(t,e);return void 0===a?n:a});let Qt;if("object"==typeof t&&"undefined"!=typeof module&&"undefined"==typeof crypto){const t=require("crypto");Qt=n=>{return t.randomBytes(n).readUIntBE(0,n)}}else Qt=t=>{const n=new ArrayBuffer(4),e=new Uint8Array(n),a=new DataView(n);switch(crypto.getRandomValues(e),t){case 1:return a.getUint8(0);case 2:return a.getUint16(0);case 3:return 16777215&a.getUint32(0);default:return a.getUint32(0)}};const Ht=(t,n)=>{const e=n-t-1;let a=0,r=1;for(;e>=r;++a)r<<=1;const o=r-1,i=Math.floor(a/8)+1,s=(Qt(i)&o)/r;return Math.ceil(s*e)+t},Kt=(...t)=>{switch(t.length){case 0:return Qt(4);case 1:return Ht(0,t[0]);case 2:return Ht(t[0],t[1]);default:throw new Error("function random: argument must <= 2")}},Xt=function*(...t){let n=0,e=1/0,a=1;switch(t.length){case 1:e=t[0];break;case 2:n=t[0],e=t[1];break;case 3:n=t[0],e=t[1],a=t[2]}for(let t=n;t!==e;t+=a)yield t},Zt=async t=>{if((t=await t)instanceof Function&&(t=await t()),t<=0)throw new Error("duration > 0 required");return t},$t=t=>new Promise((n,e)=>{setTimeout(()=>{e(new Error("timeout error"))},t)}),tn=t=>t[Kt(t.length)],nn=i(async function*(t,n,e){n=await n,yield n;for await(const a of e)n=await t(n,a),yield n}),en=i(async function*(t,n){const e=F(n),a=await e.next();a.done||(yield*nn(t,a.value,e))}),an=t=>{const n=t.length;for(let e=n-1;e>=0;--e){const a=Kt(n);if(e!==a){const n=t[e];t[e]=t[a],t[a]=n}}return t},rn=i(async(t,n)=>{for await(const e of n)if(await t(e))return!0;return!1}),on=i(async function*(t,n,e){if(n.constructor==="".constructor)switch(n.trim().toLowerCase()){case"asc":n=c;break;case"desc":n=P;break;default:throw new Error("please set order parameter to ASC or DESC or compare function")}const a=[],r=new Map;for await(const n of e)a.push(n),r.has(n)||r.set(n,await t(n));yield*a.sort((t,e)=>{const a=r.get(t),o=r.get(e);return n(a,o)})}),sn=on,cn=on(z),ln=on(z),fn=i(async function*(t,n){const e=F(n);let a;yield async function*(){for(;!(a=await e.next()).done&&!await t(a.value);)yield a.value}();yield async function*(){a.done||(yield a.value,yield*e)}()}),un=i(async function*(t,n){yield*await t(n)}),yn=(t,n)=>{if(t.constructor!==n.constructor)throw new Error("join/combine object: object is not same");if(t instanceof Map)return((t,n)=>new Map([...n,...t]))(t,n);if(t[Symbol.iterator]&&t.set&&"function"==typeof t.set)return((t,n)=>{const e=new t.constructor;for(const t of n)e.set(...t);for(const n of t)e.set(...n);return e})(t,n);if(t instanceof Object)return((t,n)=>Object.assign({},n,t))(t,n);throw new Error("join/combine object: not support type")},wn=async function*(t,n,e){const a=[],r=[],o=F(e);t:for await(const e of n){a.push(e);for(const n of r)if(await t(e,n)){yield yn(e,n);continue t}for(;;){const{value:n,done:a}=await o.next();if(a)break;if(r.push(n),await t(e,n)){yield yn(e,n);continue t}}yield e}for await(const n of o)for(const e of a)await t(e,n)&&(yield yn(e,n))},dn=async function*(t,n,e){const a=[],r=[],o=F(e);t:for await(const e of n){a.push(e);for(const n of r)if(await t(e,n)){yield yn(e,n);continue t}for(;;){const{value:n,done:a}=await o.next();if(a)break;if(r.push(n),await t(e,n)){yield yn(e,n);continue t}}}for await(const n of o)for(const e of a)await t(e,n)&&(yield yn(e,n))},hn=i(dn),pn=i(dn),mn=i((t,n,e)=>dn(t,e,n)),gn=i(wn),bn=i(wn),vn=i((t,n,e)=>wn(t,e,n)),xn=i((t,n)=>t-n),_n=ct(s),En=i(async function*(t,n){let e=0;for await(const a of n){if(++e>t)break;yield a}}),An=i(async function*(t,n){for await(const e of n){if(!await t(e))break;yield e}}),On=i(async(t,n)=>(await t(n),n)),kn=i((t,n)=>t(n)),jn=i(async(t,n)=>{t=await Zt(t);const e=$t(t);n instanceof Function&&(n=n());const a=Promise.race([e,n]),r=await a;return e.catch(it),r}),Bn=i(async function*(t,n){t=await Zt(t);const e=F(n),a=$t(t);for(;;){const t=e.next(),n=await Promise.race([a,t]);if(n.done)break;yield n.value}a.catch(it)}),In=i(async function*(t,n,e){for(n=F(n),e=F(e);;){const a=n.next(),r=e.next(),o=await a,i=await r;if(o.done||i.done)break;yield t(o.value,i.value)}}),Nn=i((t,n)=>In((t,n)=>[t,n],t,n)),Sn=i(async function*(t,n,e,a){for(n=F(n),e=F(e),a=F(a);;){const r=n.next(),o=e.next(),i=a.next(),s=await r,c=await o,l=await i;if(s.done||c.done||l.done)break;yield t(s.value,c.value,l.value)}}),Pn=i((t,n,e)=>Sn((t,n,e)=>[t,n,e],t,n,e));t._=o,t._ArrayList=e,t._Queue=a,t.add=s,t.asc=c,t.associateBy=p,t.average=async t=>{let n=0,e=0;for await(const a of t)++n,e+=a;return e/n},t.buffer=m,t.collect=g,t.collectFloat32=j,t.collectFloat64=B,t.collectInt16=x,t.collectInt32=_,t.collectInt8=v,t.collectMap=async t=>new Map(await g(t)),t.collectObject=async t=>{const n=await I(t),e={};for(const t of n){if(!Array.isArray(t))throw new TypeError("collectObject value is not array require [k,v] ");e[t[0]]=t[1]}return e},t.collectSet=async t=>new Set(await I(t)),t.collectUint16=A,t.collectUint32=O,t.collectUint8=E,t.collectUint8Clamped=k,t.compose=(...t)=>async(...n)=>{const e=t.length;let a=await t[e-1](...n);for(let n=e-2;n>=0;--n)a=await t[n](a);return a},t.concat=N,t.cond=async(...t)=>{h(t);for(let n=0;n<t.length;n+=2)if(await t[n])return t[n+1]},t.count=async t=>{if(Number.isSafeInteger(t.length))return t.length;if(Number.isSafeInteger(t.size))return t.size;if(w(t)){let n=0;for await(const e of t)++n;return n}return Object.keys(t).length},t.curry=i,t.dec=t=>t-1,t.desc=P,t.dflat=M,t.distinct=t=>U(z,t),t.distinctBy=U,t.distinctUntilChanged=R,t.distinctUntilChangedBy=W,t.drop=V,t.dropLast=G,t.dropWhile=Q,t.emptyThen=H,t.enumerate=async function*(t){let n=0;for await(const e of t)yield[n++,e]},t.equals=D,t.errorThen=K,t.every=X,t.filter=Z,t.filterIndexed=$,t.filterNot=tt,t.find=nt,t.findLast=et,t.first=t=>t[0],t.firstOrGet=at,t.flat=async function*(t){for await(const n of t)n&&w(n)?yield*n:yield n},t.flatMap=ot,t.fmap=rt,t.fnil=(t,...n)=>(...e)=>t(...Object.assign(n,e)),t.fnothing=it,t.foldl=st,t.foldl1=ct,t.foldr=yt,t.foldr1=wt,t.forEach=dt,t.forEachIndexed=ht,t.frequencies=mt,t.frequenciesBy=pt,t.get=bt,t.getOrElse=vt,t.groupBy=xt,t.has=_t,t.head=async t=>{const n=F(t),e=await n.next();if(e.done)throw new Error("empty iter");return e.value},t.identity=z,t.inc=t=>t+1,t.innerJoin=pn,t.interval=(t,n,...e)=>{(!t||t<10)&&(t=10);const a={run:!0};return(async()=>{for(;a.run;)try{const a=Et(t);await n(...e),await a}catch{}})(),a},t.isNil=At,t.iterate=Ot,t.juxtA=kt,t.juxtO=jt,t.leftInnerJoin=hn,t.leftOuterJoin=gn,t.map=Bt,t.mapIndexed=It,t.match=(t,...n)=>{h(n);for(let e=0;e<n.length;e+=2)if(D(t,n[e]))return d(n[e+1])?n[e+1](t):n[e+1]},t.max=St,t.maxBy=Nt,t.memoize=Mt,t.memoizeBy=Pt,t.memoizeWithTimeout=Ut,t.min=Ft,t.minBy=zt,t.notNil=t=>!At(t),t.order=cn,t.orderBy=sn,t.otherwise=()=>!0,t.outerJoin=bn,t.parallel_set_fetch_count=t=>(t=>{if((t=Number(t))<=0)throw new Error("count > 0 required");Tt=t||100})(t),t.pcalls=Jt,t.peek=Lt,t.pfilter=Dt,t.pflatMap=Yt,t.pfmap=Vt,t.pipe=(t,...n)=>(...e)=>st((t,n)=>n(t),t(...e),n),t.pmap=Rt,t.prop=gt,t.propOrElse=Gt,t.random=Kt,t.range=Xt,t.rangeInterval=async function*(t,...n){t=await Zt(t),await Et(t);for(const e of Xt(...n))yield e,await Et(t)},t.rangeOf=(...t)=>rt(z,t),t.reduce=lt,t.repeat=async function*(t,...n){const[e,a]=await(async(t,n)=>(t=await t,n.length>0?[t,await n[0]]:[1/0,t]))(t,n);if(a instanceof Function)for(let t=e;t>0;--t)yield a();else for(let t=e;t>0;--t)yield a},t.reverse=ft,t.rightInnerJoin=mn,t.rightOuterJoin=vn,t.run=(t,...n)=>st((t,n)=>n(t),t,n),t.sample=t=>y(t)?tn(t):(async t=>{const n=await g(t);return tn(n)})(t),t.scanl=nn,t.scanl1=en,t.second=t=>t[1],t.seq=F,t.shuffle=t=>y(t)?an(Array.from(t)):(async t=>(t=await g(t),an(t)))(t),t.sleep=Et,t.some=rn,t.sort=ln,t.sortBy=on,t.split=fn,t.splitBy=un,t.sub=xn,t.sum=_n,t.tail=async function*(t){const n=F(t),{done:e}=await n.next();if(e)throw new Error("empty iter");yield*n},t.take=En,t.takeWhile=An,t.tap=On,t.then=kn,t.timeout=jn,t.underBar=r,t.union=S,t.withTimeout=Bn,t.zip=Nn,t.zip3=Pn,t.zipWith=In,t.zipWith3=Sn,Object.defineProperty(t,"__esModule",{value:!0})});
