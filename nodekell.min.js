!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).F={})}(this,(function(t){"use strict";const e=t=>(...n)=>t.length<=n.length?t(...n):(...a)=>e(t)(...n,...a),n=e((t,e)=>t+e),a=32;class r{constructor(t){const e=new ArrayBuffer(t.BYTES_PER_ELEMENT*a);this._data=new t(e),this._ctor=t,this._length=0}_grow(t){const e=this._ctor.BYTES_PER_ELEMENT,n=new ArrayBuffer(t*e),a=new this._ctor(n),r=this._data;a.set(r),this._data=a}add(t){const e=this._length;e===this._data.length&&this._grow(2*e),this._data[e]=t,this._length+=1}get(t){return this._data[t]}set(t,e){this._data[t]=e}get length(){return this._length}clear(){this._length=0}*[Symbol.iterator](){for(let t=0;t<this._length;++t)yield this._data[t]}toArray(){return this._data.slice(0,this._length)}}const o=(t,e)=>t>e?1:t<e?-1:0,i=e((t,e,...n)=>Object.assign(t,e,...n)),s=e((t,e,n,...a)=>Object.assign(t,e,n,...a)),c=e((t,e,...n)=>Object.assign.call(null,[t,e,...n].reverse()));let l=100;const f=()=>l,u=async t=>((t=await t).constructor===Function&&(t=await t()),t),y=async t=>{if(t)for(;;){const{value:e,done:n}=await t.next();if(n)break;await e}},w=async function*(t,e){for(;;){const n=await Promise.all(e.map(t=>t.next()));for(let t=0;t<n.length;++t)if(n[t].done)return;yield t.apply(null,n.map(t=>t.value))}},d=t=>{if(!t)throw new Error("error iter result");if(t.done)throw new Error("empty iter")},h=t=>ArrayBuffer.isView(t)&&!(t instanceof DataView),p=t=>!!Number.isSafeInteger(t.length)&&(t=>0===t.length?1===Object.keys(t).length:Object.prototype.hasOwnProperty.call(t,t.length-1))(t),m=t=>t.constructor===String,g=t=>Array.isArray(t)||h(t)||p(t),b=t=>t&&(m(t)||g(t)),v=t=>t[Symbol.iterator]||t[Symbol.asyncIterator],x=t=>t&&t.constructor===Function,E=t=>{if(1&t.length)throw new Error("requires an even arguments")},_=e(async(t,e)=>{const n=new Map;for await(const a of e){const e=await t(a);b(e)?n.set(e[0],e[1]):n.set(e,e)}return n}),A=t=>{const e=t[Symbol.asyncIterator];return e?e.call(t):async function*(t){for await(const e of t)yield e}(t)},O=t=>{if(t){const e=t[Symbol.iterator];if(e)return e.call(t);const n=t[Symbol.asyncIterator];if(n)return n.call(t)}},k=t=>{if(t){const e=O(t);return e||function*(t){const e=Object.keys(t);for(const n of e)yield[n,t[n]]}(t)}},S=(t,e)=>(async function*(n){n=k(n);for await(const a of n)g(a)?yield a[t]:e(a)}),j=async function*(t){(t=await t)&&v(t)?yield*t:yield t},P=async(t,e,n)=>{t=Math.max(t,0);const a=A(e);for(let e=t;e>0;--e){const t=await a.next();if(t.done)break;n(t.value)}return a},I=e((async function*(t,e){if((t=await t)<=0)throw new Error("arg supply > 0 required");let n=[];for await(const a of e){n.push(a)>=t&&(yield n,n=[])}0!==n.length&&(yield n)})),B=async t=>{const e=[];for await(const n of t)e.push(n);return e},N=t=>Array.isArray(t)?Promise.all(t):h(t)?t:m(t)?Array.from(t):p(t)?Promise.all(Array.from(t)):B(t),M=async t=>new Map(await N(t)),U=t=>async e=>{const n=new r(t);for await(const t of e)n.add(t);return n.toArray()},z=U(Int8Array),F=U(Int16Array),R=U(Int32Array),q=U(Uint8Array),T=U(Uint16Array),C=U(Uint32Array),J=U(Uint8ClampedArray),L=U(Float32Array),W=U(Float64Array),D=async t=>{const e=await N(t),n={};for(const t of e){if(!Array.isArray(t))throw new TypeError("collectObject value is not array require [k,v] ");n[t[0]]=t[1]}return n},V=t=>t?-1:0,Y=(t,e,n)=>a=>a?1:((t,e,n)=>{const a=t(e,n);return a instanceof Promise?a.then(V):V(a)})(t,e,n),$=(t,e,n)=>{const a=t(n,e);return a instanceof Promise?a.then(Y(t,e,n)):Y(t,e,n)(a)},G=e((t,e,n)=>e instanceof Promise||n instanceof Promise?(async(t,e,n)=>$(t,await e,await n))(t,e,n):$(t,e,n)),Q=e((async function*(t,e){yield*j(t),yield*j(e)})),H=Q,K=(t,e)=>t<e?1:t>e?-1:0,X=async function*(...t){for await(const e of t){if(e){if(m(e)){yield*e;continue}if(v(e)){for await(const t of e)yield*X(t);continue}}yield e}},Z=e((async function*(t,e){const n=new Set;for await(const a of e){const e=await t(a);n.has(e)||(n.add(e),yield a)}})),tt=t=>t,et=t=>Array.isArray(t)||h(t)||m(t)?(async t=>{if(0!==t.length)return[await t[0],t.slice(1)];throw new Error("empty array")})(t):(async t=>{const e=A(t),n=await e.next();return d(n),[n.value,e]})(t),nt=async t=>{return await et(t)},at=Object.freeze({}),rt=at;let ot;const it=(t,e)=>{const n=t.length;if(n!==e.length)return!1;for(let a=n-1;a>=0;--a)if(!ot(t[a],e[a]))return!1;return!0},st=(t,e,n)=>{try{const a=e.call(t,n);if(null!=a)return a}catch(t){}},ct=["number","string","default"],lt=t=>{const e=t[Symbol.toPrimitive];if(e)for(const n of ct){const a=st(t,e,n);if(void 0!==a)return a}},ft=t=>Object.prototype.toString(t),ut=ot=e((t,e)=>{if(t===e)return!0;if(t===at||e===at)return!0;if(t&&e){if(t.constructor!==e.constructor)return!1;if((t=>{switch(t.constructor){case Number:case BigInt:case Boolean:case Symbol:case String:return!0}return!1})(t))return t.valueOf()===e.valueOf();const n=lt(t);return n?n===lt(e):t.valueOf()===e.valueOf()||(t instanceof Array?it(t,e):h(t)?((t,e)=>{const n=t.length;if(n!==e.length)return!1;for(let a=n-1;a>=0;--a)if(t[a]!==e[a])return!1;return!0})(t,e):p(t)?it(t,e):t instanceof Map?((t,e)=>{if(t.size!==e.size)return!1;for(const n of t){if(!e.has(n[0]))return!1;if(!ot(e.get(n[0]),n[1]))return!1}return!0})(t,e):t instanceof Set?((t,e)=>{if(t.size!==e.size)return!1;for(const n of t)if(!e.has(n))return!1;return!0})(t,e):t instanceof RegExp?((t,e)=>t.sticky===e.sticky&&(t.unicode===e.unicode&&(t.ignoreCase===e.ignoreCase&&(t.global===e.global&&(t.multiline===e.multiline&&t.source===e.source)))))(t,e):!(t instanceof Promise)&&(ft(t)===ft(e)&&((t,e)=>{const n=Object.entries(t);if(n.length!==Object.keys(e).length)return!1;for(const[t,a]of n){if(!e.hasOwnProperty(t))return!1;if(!ot(a,e[t]))return!1}return!0})(t,e)))}return!(!Number.isNaN(t)||!Number.isNaN(e))}),yt=e((async function*(t,e){let[n,a]=await nt(e);yield n,n=await t(n);for await(const e of a){const a=await t(e);ut(n,a)||(n=a,yield e)}})),wt=yt(tt),dt=e(async(t,e,...n)=>{await e.call(t,t);for await(const e of n)await e.call(t,t);return t}),ht=e((async function*(t,e){const n=A(e);for(let e=0;e<t;e++){if((await n.next()).done)break}yield*n}));class pt{constructor(){this.head=this.tail=null}add(t){const e={value:t,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e}_unsafePop(){const t=this.head;return t!==this.tail?this.head=t.next:this.head=this.tail=null,t.next=null,t.value}remove(){if(null===this.head)throw new Error("no such element");return this._unsafePop()}poll(){return null===this.head?null:this._unsafePop()}element(){const t=this.head;if(null===t)throw new Error("no such element");return t.value}peek(){const t=this.head;return null===t?null:t.value}isEmpty(){return null===this.head}clear(){let t=this.head;for(;t;){const e=t.next;t.value=t.next=null,t=e}this.head=this.tail=null}*[Symbol.iterator](){let t=this.head;for(;t;)yield t.value,t=t.next}*removeIterator(){let t=this.head;for(;t;){const e=t;yield e.value,t=e.next,e.value=null,e.next=null}}}const mt=async(t,e)=>{const n=await e.next();return!n.done&&(t.add(n.value),!0)},gt=e((async function*(t,e){const n=A(e),a=new pt;for(let e=0;e<t;e++)if(!await mt(a,n))return;for(;await mt(a,n);)yield a.poll()})),bt=e((async function*(t,e){const n=A(e);for(;;){const e=await n.next();if(e.done)return;if(!await t(e.value)){yield e.value;break}}yield*n})),vt=e((async function*(t,e){for await(const t of e)return yield t,void(yield*e);yield*j(u(t))})),xt=e(async(t,e)=>{for await(const n of e)if(!await t(n))return!1;return!0}),Et=e((async function*(t,e){for await(const n of e)await t(n)&&(yield n)})),_t=e((async function*(t,e){let n=0;for await(const a of e)await t(n++,a)&&(yield a)})),At=e((async function*(t,e){for await(const n of e)await t(n)||(yield n)})),Ot=e(async(t,e)=>{for await(const n of e)if(await t(n))return n}),kt=e(async(t,e)=>{for(let n=(e=await N(e)).length-1;n>=0;--n)if(await t(e[n]))return e[n]}),St=e(async(t,e)=>{for await(const t of e)return t;return u(t)}),jt=async function*(t){for await(const e of t)yield*j(e)},Pt=e((async function*(t,e){for await(const n of e)yield*await t(n)})),It=Pt,Bt=()=>{},Nt=e(async(t,e,n)=>{e=await e;for await(const a of n)e=await t(e,a);return e}),Mt=e(async(t,e)=>{const[n,a]=await nt(e);return Nt(t,n,a)}),Ut=Mt,zt=async function*(t){const e=await N(t);for(let t=e.length-1;t>=0;t-=1)yield e[t]},Ft=async(t,e,n)=>{e=await e;for await(const a of n)e=await t(a,e);return e},Rt=e((t,e,n)=>Ft(t,e,zt(n))),qt=e(async(t,e)=>{const n=zt(e),[a,r]=await nt(n);return Ft(t,a,r)}),Tt=e(async(t,e)=>{const n=[];for await(const a of e)n.push(t(a));return Promise.all(n)}),Ct=e(async(t,e)=>{const n=[];let a=0;for await(const r of e)n.push(t(a++,r));return Promise.all(n)}),Jt=e(async(t,e)=>{const n=new Map;for await(const a of e){const e=await t(a),r=(n.get(e)||0)+1;n.set(e,r)}return n}),Lt=Jt(tt),Wt=e((t,e)=>{if(null!=e)return e[t]}),Dt=e((t,e)=>{if(e&&x(e.get)){const n=e.get(t);if(void 0!==n)return n}return Wt(t,e)}),Vt=e((t,e,n)=>{const a=Dt(t,n);return void 0===a?e:a}),Yt=e(async(t,e)=>{const n=new Map;for await(const a of e){const e=await t(a),r=n.get(e);r?r.push(a):n.set(e,[a])}return n}),$t=e((t,e)=>!!e&&(!(!x(e.has)||!e.has(t))||void 0!==e[t])),Gt=e((async function*(t,e,n){e=A(e);const{value:a,done:r}=await e.next();if(r)return;const o=[];for await(const e of n)await t(a,e)&&(yield[a,e]),o.push(e);for await(const n of e)for(let e=0;e<o.length;++e){const a=o[e];await t(n,a)&&(yield[n,a])}})),Qt=e((async function*(t,e,n){let a=0;for await(const r of n)a++===e&&(yield*j(t)),yield r;a<=e&&(yield*j(t))})),Ht=t=>new Promise(e=>{setTimeout(e,t)}),Kt=t=>null==t||Object(t)!==t,Xt=e((async function*(t,e){for(e=await e,yield e;;)e=await t(e),yield e})),Zt=e(async(t,e)=>{const n=(t=await N(t)).length,a=A(e),r=[];r.length=n;const o=await a.next();return o.done?r:(r.fill(o.value),Nt((e,n)=>Ct((e,a)=>t[e](a,n),e),r,a))}),te=e(async(t,e)=>{const n=[];for await(const a of t)n.push(Dt(a,e));return n}),ee=S(0,t=>{throw new Error(`keys / ${t} is not array`)}),ne=e((async function*(t,e){for await(const n of e)yield t(n)})),ae=e((async function*(t,e){let n=0;for await(const a of e)yield t(n++,a)})),re=e(async(t,e)=>{let[n,a]=await nt(e),r=await t(n);for await(const e of a){const a=await t(e);a>r&&(n=e,r=a)}return n}),oe=re(tt),ie=e((t,e)=>{const n={};return async(...a)=>{let r;const o=await t(...a);return o in n?r=n[o]:(r=await e(...a),n[o]=r),r}}),se=ie((...t)=>t),ce=e((t,e)=>((t,e,n)=>{const a={};return async(...r)=>{const o=Date.now(),i=await e(...r),s=a[i];if(!s||o-s.time>t){const t=await n(...r);return a[r]={value:t,time:o},t}return s.value}})(t,(...t)=>t,e)),le=(t,...e)=>Nt((t,e)=>e(t),t,e),fe=e(async(t,e,...n)=>await le([t,e,...n],ne(k),jt,M)),ue=e((t,e,...n)=>fe.apply(null,[t,e,...n].reverse())),ye=e(async(t,e,...n)=>await le([t,e,...n],ne(k),jt,D)),we=e((t,e,...n)=>ye.apply(null,[t,e,...n].reverse())),de=e(async(t,e)=>{let[n,a]=await nt(e),r=await t(n);for await(const e of a){const a=await t(e);a<r&&(n=e,r=a)}return n}),he=de(tt),pe=e((async function*(t,e,n){if(e.constructor==="".constructor)switch(e.trim().toLowerCase()){case"asc":e=o;break;case"desc":e=K;break;default:throw new Error("please set order parameter to ASC or DESC or compare function")}const a=[],r=new Map;for await(const e of n)a.push(e),r.has(e)||r.set(e,await t(e));yield*a.sort((t,n)=>{const a=r.get(t),o=r.get(n);return e(a,o)})})),me=pe(tt),ge=async function*(t){const e=new pt,n=await((t,e)=>{const n=f()-1;return P(n,e,e=>t.add(e()))})(e,t);for await(const t of n)e.add(t()),yield e.poll();yield*e.removeIterator()},be=e((async function*(...t){1===t.length&&v(t[0])?yield*ge(t[0]):yield*ge(t)})),ve=e((async function*(t,e){for await(const n of e)await t(n),yield n})),xe=e((async function*(t,e){const n=new pt,a=new pt,r=await((t,e,n,a)=>{const r=f()-1;return P(r,a,a=>{t.add(n(a)),e.add(a)})})(n,a,t,e);for await(const e of r){n.add(t(e)),a.add(e);const r=a.poll();await n.poll()&&(yield r)}for(;!a.isEmpty();){const t=a.poll();await n.poll()&&(yield t)}})),Ee=(t,e,n)=>{const a=f()-1;return P(a,n,n=>t.add(e(n)))},_e=e((async function*(t,e){const n=new pt,a=await Ee(n,t,e);for await(const e of a)n.add(t(e)),yield n.poll();yield*n.removeIterator()})),Ae=e((async function*(t,e){const n=new pt,a=await Ee(n,t,e);for await(const e of a)n.add(t(e)),yield*await n.poll();for(;!n.isEmpty();)yield*await n.poll()})),Oe=Ae,ke=e((t,e,n)=>{const a=Wt(t,n);return void 0===a?e:a});let Se;if("object"==typeof t&&"undefined"!=typeof module&&"undefined"==typeof crypto){const t=require("crypto");Se=e=>{return t.randomBytes(e).readUIntBE(0,e)}}else Se=t=>{const e=new ArrayBuffer(4),n=new Uint8Array(e),a=new DataView(e);switch(crypto.getRandomValues(n),t){case 1:return a.getUint8(0);case 2:return a.getUint16(0);case 3:return 16777215&a.getUint32(0);default:return a.getUint32(0)}};const je=(t,e)=>{const n=e-t-1;let a=0,r=1;for(;n>=r;++a)r<<=1;const o=r-1,i=Math.floor(a/8)+1,s=(Se(i)&o)/r;return Math.ceil(s*n)+t},Pe=(...t)=>{switch(t.length){case 0:return Se(4);case 1:return je(0,t[0]);case 2:return je(t[0],t[1]);default:throw new Error("function random: argument must <= 2")}},Ie=function*(...t){let e=0,n=1/0,a=1;switch(t.length){case 1:n=t[0];break;case 2:e=t[0],n=t[1];break;case 3:e=t[0],n=t[1],a=t[2]}if(e>n)for(let t=e;t>n;t+=a)yield t;else for(let t=e;t<n;t+=a)yield t},Be=async t=>{if((t=await u(t))<=0)throw new Error("duration > 0 required");return t},Ne=t=>new Promise((e,n)=>{setTimeout(()=>{n(new Error("timeout error"))},t)}),Me=e((t,e)=>{return t.constructor!==RegExp&&(t=new RegExp(t)),t.exec(e)||[]}),Ue=e((t,e)=>{return Me(t,e)[0]||""}),ze=(t,e,n)=>{for(t=(t=>t.constructor===RegExp?(t.global||(t=new RegExp(t,t.flags+"g")),t.lastIndex=0,t):new RegExp(t,"g"))(t);;){const a=t.exec(e);if(!a)break;n(a)}},Fe=e((t,e)=>{const n=[];return ze(t,e,t=>n.push(t[0])),n}),Re=e((t,e)=>{const n=[];return ze(t,e,t=>n.push(t)),n}),qe=t=>t[Pe(t.length)],Te=e((async function*(t,e,n){e=await e,yield e;for await(const a of n)e=await t(e,a),yield e})),Ce=e((async function*(t,e){const n=A(e),a=await n.next();a.done||(yield*Te(t,a.value,n))})),Je=t=>{const e=t.length;for(let n=e-1;n>=0;--n){const a=Pe(e);if(n!==a){const e=t[n];t[n]=t[a],t[a]=e}}return t},Le=e(async(t,e)=>{for await(const n of e)if(await t(n))return!0;return!1}),We=async(t,e,n,a,r)=>{for(;;){if(r<=a)return await t(n,e[a])>0?a+1:a;const o=Math.floor((a+r)/2),i=await t(n,e[o]);if(0===i)return o;i>0?a=o+1:r=o-1}},De=async(t,e,n,a)=>{for(let r=n+1;r<=a;++r){const a=e[r],o=await We(t,e,a,n,r);for(let t=r-1;t>=o;--t)e[t+1]=e[t];e[o]=a}},Ve=async(t,e,n,a,r)=>{if(a<r)if(r-a<1)await De(t,e,a,r);else{const o=Math.floor((a+r)/2),i=Ve(t,e,n,a,o),s=Ve(t,e,n,o+1,r);await i,await s,await(async(t,e,n,a,r,o)=>{let i=a,s=r+1,c=a;for(;i<=r&&s<=o;++c)await t(e[i],e[s])<=0?(n[c]=e[i],++i):(n[c]=e[s],++s);if(i>r)for(;s<=o;++s,++c)n[c]=e[s];else for(;i<=r;++i,++c)n[c]=e[i];for(c=a;c<=o;++c)e[c]=n[c]})(t,e,n,a,o,r)}},Ye=e(async(t,e)=>{const n=await N(e),a=[];return a.length=n.length,await Ve(t,n,a,0,n.length-1),n}),$e=Ye(o),Ge=e((async function*(t,e){yield*await t(e)})),Qe=(t,e)=>{if(t.constructor!==e.constructor)throw new Error("join/combine object: object is not same");if(t instanceof Map)return((t,e)=>new Map([...e,...t]))(t,e);if(t[Symbol.iterator]&&t.set&&"function"==typeof t.set)return((t,e)=>{const n=new t.constructor;for(const t of e)n.set(...t);for(const e of t)n.set(...e);return n})(t,e);if(t instanceof Object)return((t,e)=>Object.assign({},e,t))(t,e);throw new Error("join/combine object: not support type")},He=async function*(t,e,n){const a=[],r=[],o=A(n);t:for await(const n of e){a.push(n);for(const e of r)if(await t(n,e)){yield Qe(n,e);continue t}for(;;){const{value:e,done:a}=await o.next();if(a)break;if(r.push(e),await t(n,e)){yield Qe(n,e);continue t}}yield n}for await(const e of o)for(const n of a)await t(n,e)&&(yield Qe(n,e))},Ke=async function*(t,e,n){const a=[],r=[],o=A(n);t:for await(const n of e){a.push(n);for(const e of r)if(await t(n,e)){yield Qe(n,e);continue t}for(;;){const{value:e,done:a}=await o.next();if(a)break;if(r.push(e),await t(n,e)){yield Qe(n,e);continue t}}}for await(const e of o)for(const n of a)await t(n,e)&&(yield Qe(n,e))},Xe=e(Ke),Ze=e(Ke),tn=e((t,e,n)=>Ke(t,n,e)),en=e(He),nn=e(He),an=e((t,e,n)=>He(t,n,e));const rn=e((t,e)=>t-e),on=Mt(n),sn=e((async function*(t,e){let n=0;for await(const a of e){if(++n>t)break;yield a}})),cn=e((async function*(t,e){const n=new pt,a=await P(t,e,t=>n.add(t));for await(const t of a)n.add(t),n.poll();yield*n.removeIterator()})),ln=e((async function*(t,e){for await(const n of e){if(!await t(n))break;yield n}})),fn=e(async(t,e)=>(await t(e),e)),un=e((t,e)=>t(e)),yn=e(async(t,e)=>{t=await Be(t);const n=Ne(t);e instanceof Function&&(e=e());const a=Promise.race([n,e]),r=await a;return n.catch(Bt),r}),wn=S(1,t=>{throw new Error(`values / ${t} is not array`)}),dn=e((async function*(t,e){t=await Be(t);const n=A(e),a=Ne(t);for(;;){const t=n.next(),e=await Promise.race([a,t]);if(e.done)break;yield e.value}a.catch(Bt)})),hn=e((async function*(t,e,n){yield*w(t,[A(e),A(n)])})),pn=e((t,e)=>hn((t,e)=>[t,e],t,e)),mn=e((async function*(t,e,n,a){yield*w(t,[A(e),A(n),A(a)])})),gn=e((t,e,n)=>mn((t,e,n)=>[t,e,n],t,e,n));t._=rt,t._ArrayList=r,t._Queue=pt,t._Stack=class{constructor(){this.top=null}push(t){const e=this.top;this.top={value:t,next:e}}_unsafePop(){const t=this.top.value;return this.top=this.top.next,t}pop(){if(null===this.top)throw new Error("no such element");return this._unsafePop()}poll(){return null===this.top?null:this._unsafePop()}peek(){const t=this.top;return null===t?null:t.value}isEmpty(){return null===this.top}clear(){let t=this.top;for(;t;){t.value=null;const e=t.next;t.next=null,t=e}this.top=null}*[Symbol.iterator](){let t=this.top;for(;t;)yield t.value,t=t.next}*removeIterator(){let t=this.top;for(;t;){const e=t;yield e.value,t=e.next,e.value=null,e.next=null}}},t._binarySearchIndex=We,t._insertionSort=De,t.add=n,t.asc=o,t.assign=i,t.assign3=s,t.assignRight=c,t.associateBy=_,t.average=async t=>{let e=0,n=0;for await(const a of t)++e,n+=a;return n/e},t.block=async(...t)=>{t=await Promise.all(t);for(const e of t){const t=O(e);await y(t)}},t.buffer=I,t.collect=B,t.collectFloat32=L,t.collectFloat64=W,t.collectInt16=F,t.collectInt32=R,t.collectInt8=z,t.collectMap=M,t.collectObject=D,t.collectSet=async t=>new Set(await N(t)),t.collectUint16=T,t.collectUint32=C,t.collectUint8=q,t.collectUint8Clamped=J,t.comparator=G,t.compose=(...t)=>async(...e)=>{const n=t.length;let a=await t[n-1](...e);for(let e=n-2;e>=0;--e)a=await t[e](a);return a},t.concat=Q,t.cond=async(...t)=>{E(t);for(let e=0;e<t.length;e+=2)if(await t[e])return t[e+1]},t.count=async t=>{if(Number.isSafeInteger(t.length))return t.length;if(Number.isSafeInteger(t.size))return t.size;if(v(t)){let e=0;for await(const n of t)++e;return e}return Object.keys(t).length},t.curry=e,t.dec=t=>t-1,t.desc=K,t.dflat=X,t.distinct=t=>Z(tt,t),t.distinctBy=Z,t.distinctUntilChanged=wt,t.distinctUntilChangedBy=yt,t.doto=dt,t.drop=ht,t.dropLast=gt,t.dropWhile=bt,t.emptyThen=vt,t.enumerate=async function*(t){let e=0;for await(const n of t)yield[e++,n]},t.equals=ut,t.every=xt,t.filter=Et,t.filterIndexed=_t,t.filterNot=At,t.find=Ot,t.findLast=kt,t.first=t=>t[0],t.firstOrGet=St,t.flat=jt,t.flatMap=It,t.fmap=Pt,t.fnil=(t,...e)=>(...n)=>t(...Object.assign(e,n)),t.fnothing=Bt,t.foldl=Nt,t.foldl1=Mt,t.foldr=Rt,t.foldr1=qt,t.forEach=Tt,t.forEachIndexed=Ct,t.frequencies=Lt,t.frequenciesBy=Jt,t.get=Dt,t.getOrElse=Vt,t.groupBy=Yt,t.has=$t,t.head=async t=>{const e=A(t),n=await e.next();return d(n),n.value},t.identity=tt,t.inc=t=>t+1,t.innerJoin=Ze,t.innerJoin2=Gt,t.insertAt=Qt,t.interval=(t,e,...n)=>{t=Number(t),Number.isNaN(t)&&t<1&&(t=1);const a={run:!0},r=async()=>{const o=Ht(t);try{await e(...n)}catch(t){}a.run&&o.then(r)};return r(),a},t.isNil=t=>{if(t)return!1;switch(t){case null:case void 0:return!0;default:return Number.isNaN(t)}},t.isPrimitive=Kt,t.iterate=Xt,t.juxtA=Zt,t.juxtO=te,t.keys=ee,t.leftInnerJoin=Xe,t.leftOuterJoin=en,t.map=ne,t.mapIndexed=ae,t.match=(t,...e)=>{E(e);for(let n=0;n<e.length;n+=2)if(ut(t,e[n]))return x(e[n+1])?e[n+1](t):e[n+1]},t.max=oe,t.maxBy=re,t.memoize=se,t.memoizeBy=ie,t.memoizeWithTimeout=ce,t.mergeMap=fe,t.mergeMapRight=ue,t.mergeObject=ye,t.mergeObjectRight=we,t.min=he,t.minBy=de,t.order=me,t.orderBy=pe,t.otherwise=()=>!0,t.outerJoin=nn,t.parallel_set_fetch_count=t=>(t=>{if((t=Number(t))<=0)throw new Error("parallel_fetch_count > 0 required");l=t||100})(t),t.pcalls=be,t.peek=ve,t.pfilter=xe,t.pflatMap=Oe,t.pfmap=Ae,t.pipe=(t,...e)=>(...n)=>Nt((t,e)=>e(t),t(...n),e),t.pmap=_e,t.prop=Wt,t.propOrElse=ke,t.random=Pe,t.range=Ie,t.rangeInterval=async function*(t,...e){t=await Be(t),await Ht(t);for(const n of Ie(...e))yield n,await Ht(t)},t.reFind=Ue,t.reFindAll=Fe,t.reFindAllSubmatch=Re,t.reFindSubmatch=Me,t.reduce=Ut,t.repeat=async function*(t,...e){const[n,a]=await(async(t,e)=>(t=await t,e.length>0?[t,await e[0]]:[1/0,t]))(t,e);if(a instanceof Function)for(let t=n;t>0;--t)yield a();else for(let t=n;t>0;--t)yield a},t.reverse=zt,t.rightInnerJoin=tn,t.rightOuterJoin=an,t.run=le,t.sample=t=>b(t)?qe(t):(async t=>{const e=await B(t);return qe(e)})(t),t.scanl=Te,t.scanl1=Ce,t.second=t=>t[1],t.seq=A,t.shuffle=t=>b(t)?Je(Array.from(t)):(async t=>(t=await B(t),Je(t)))(t),t.sleep=Ht,t.some=Le,t.sort=$e,t.sortBy=Ye,t.splitBy=Ge,t.sub=rn,t.sum=on,t.tail=async function*(t){const e=A(t),n=await e.next();d(n),yield*e},t.take=sn,t.takeLast=cn,t.takeWhile=ln,t.tap=fn,t.then=un,t.timeout=yn,t.underBar=at,t.union=H,t.values=wn,t.withTimeout=dn,t.zip=pn,t.zip3=gn,t.zipWith=hn,t.zipWith3=mn,Object.defineProperty(t,"__esModule",{value:!0})}));
